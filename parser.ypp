%{
        #include <stdio.h>
        #include "hw3_output.hpp"
        #include "semantic.h"
        #include "classes.h"
        #include <iostream>
        #include <stdlib.h>

        using namespace std;
        using namespace output;

	extern int yylex();
        extern int yylineno;
	int yyerror(const char * message);
%}

%nonassoc VOID INT BYTE B BOOL
%left ID NUM STRING
%right ASSIGN
%left OR
%left AND
%nonassoc TRUE FALSE RETURN IF WHILE BREAK CONTINUE COMMA LBRACE RBRACE
%left RELOP_EQ
%left RELOP
%left BINOP
%left BINOP_MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%left SC
%nonassoc ELSE

%%

Program :  OPEN_SCOPE Funcs {sem->findMain();sem->closeScope(); delete sem;}

Funcs   :/* Epsilon */
        |FuncDecl Funcs

FuncDecl:RetType ID LPAREN Formals RPAREN LBRACE {sem->declareFunction((Type*)$1, $2, (Formals*)$4);} Statements RBRACE {sem->closeScope();}   

RetType :Type {$$ = new Type((Type*)$1);}
        |VOID {$$ = new Type(V_VOID);}
 
Formals :/* Epsilon */ {$$ = new Formals();}
        |FormalsList {$$ = new Formals((FormalsList*)$1);}

FormalsList : FormalDecl {$$ = new FormalsList((FormalDecl*)$1);} 
            | FormalDecl COMMA FormalsList {$$ = new FormalsList((FormalDecl*)$1, (FormalsList*)$3);}

FormalDecl  :Type ID {$$ = new FormalDecl((Type*)$1, $2);}

Statements  :Statement
            |Statements Statement

Statement   :LBRACE OPEN_SCOPE Statements {sem->closeScope();} RBRACE 
        |Type ID SC {$$ = new Statement((Type*)$1,$2);}
        |Type ID ASSIGN Exp SC {$$ = new Statement((Type*)$1,$2,(Exp*)$4);}
        |ID ASSIGN Exp SC {$$ = new Statement($1,(Exp*)$3);}
        |Call SC {$$ = new Statement((Call*)$1);}
        |RETURN SC {$$ = new Statement($1);}
        |RETURN Exp SC {$$ = new Statement($1,(Exp*)$2);}
        |IF LPAREN Exp RPAREN Statement {$$ = new Statement($1,(Exp*)$3,(Statement*)$5);}
        |IF LPAREN Exp RPAREN Statement ELSE Statement {$$ = new Statement((Exp*)$3,(Statement*)$5,(Statement*)$7);}
        |WHILE WHILE_M LPAREN Exp RPAREN Statement {$$ = new Statement($1,(Exp*)$4,(Statement*)$6);}
        |BREAK SC {$$ = new Statement($1);}
        |CONTINUE SC {$$ = new Statement($1);}

WHILE_M : /*epsilon*/ {sem->start_while();}

Call    :ID LPAREN ExpList RPAREN {$$ = new Call($1,(Explist*)$3);}
        |ID LPAREN RPAREN {$$ = new Call($1);}

ExpList :Exp {$$ = new Explist((Exp*)$1);}
        |Exp COMMA ExpList {$$ = new Explist((Exp*)$1, (Explist*)$3);}

Type    :INT {$$ = new Type(V_INT);}
        |BYTE {$$ = new Type(V_BYTE);}
        |BOOL {$$ = new Type(V_BOOL);}

Exp :LPAREN Exp RPAREN {$$ = new Exp ((Exp*)$2);}
    |Exp IF LPAREN Exp RPAREN ELSE Exp {$$ = new Exp ((Exp*)$1, (Exp*)$4, (Exp*)$7);}
    |Exp BINOP Exp {$$ = new Exp ((Exp*)$1, $2, (Exp*)$3);}
    |Exp BINOP_MUL_DIV Exp {$$ = new Exp ((Exp*)$1, $2, (Exp*)$3);}
    |ID {$$ = new Exp ($1);}
    |Call {$$ = new Exp ((Call*)$1);}
    |NUM {$$ = new Exp ($1);}
    |NUM B {$$ = new Exp ($1, $2);}
    |STRING {$$ = new Exp ($1);}
    |TRUE {$$ = new Exp ($1);}
    |FALSE {$$ = new Exp ($1);}
    |NOT Exp {$$ = new Exp ($1, (Exp*)$2);}
    |Exp AND Exp {$$ = new Exp(V_BOOL, (Exp*)$1, $2, (Exp*)$3);}
    |Exp OR Exp {$$ = new Exp(V_BOOL, (Exp*)$1, $2, (Exp*)$3);}
    |Exp RELOP Exp {$$ = new Exp (V_BOOL, (Exp*)$1, $2, (Exp*)$3);}
    |Exp RELOP_EQ Exp {$$ = new Exp (V_BOOL, (Exp*)$1, $2, (Exp*)$3);}
    |LPAREN Type RPAREN Exp {$$ = new Exp ((Type*)$2,(Exp*)$4);} 


OPEN_SCOPE : /*epsilon */ {sem->openScope();}
%%

int main()
{
        yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
}
