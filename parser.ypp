%{
        #include "hw3_output.hpp"
        #include "semantic.h"
        #include <iostream>
        #include <stdlib.h>

        using namespace std;
        using namespace output;

	extern int yylex();
        extern int yylineno;
	int yyerror(const char * message);
%}



#define YYSTYPE Node*

%nonassoc VOID INT BYTE B BOOL
%left ID NUM STRING
%right ASSIGN
%left OR
%left AND
%nonassoc TRUE FALSE RETURN IF WHILE BREAK CONTINUE COMMA LBRACE RBRACE
%left RELOP_EQ
%left RELOP
%left BINOP
%left BINOP_MUL_DIV
%right NOT
%left LPAREN
%left RPAREN
%left SC
%nonassoc ELSE

%%

Program :   Funcs

Funcs   :/* Epsilon */
        |FuncDecl Funcs

FuncDecl:RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE

RetType :Type
        |VOID 

Formals :/* Epsilon */ 
        |FormalsList

FormalsList :FormalDecl
            | FormalDecl COMMA FormalsList

FormalDecl  :Type ID {
                //Table.insert($1.type, $2.name)

            }

Statements  :Statement
            |Statements Statement

Statement   :LBRACE Statements RBRACE 
        |Type ID SC 
        |Type ID ASSIGN Exp SC //int x = hello; calling to function to figure out what is the type of Exp in the symbol table
        |ID ASSIGN Exp SC
        |Call SC
        |RETURN SC
        |RETURN Exp SC
        |IF LPAREN Exp RPAREN Statement
        |IF LPAREN Exp RPAREN Statement ELSE Statement
        |WHILE LPAREN Exp RPAREN Statement
        |BREAK SC
        |CONTINUE SC
                
Call    :ID LPAREN ExpList RPAREN
        |ID LPAREN RPAREN

ExpList :Exp
        |Exp COMMA ExpList

Type    :INT {$$ = new Type("int");}
        |BYTE {$$ = new Type("byte");}
        |BOOL {$$ = new Type("bool");}

Exp :LPAREN Exp RPAREN
    |Exp Exp IF LPAREN Exp RPAREN ELSE Exp
    |Exp BINOP Exp
    |Exp BINOP_MUL_DIV Exp
    |ID {$$ = new Exp ($1.name);}
    |Call
    |NUM 
    |NUM B
    |STRING
    |TRUE
    |FALSE
    |NOT Exp {if($2.type != V_BOOL) errorMismatch(yylineno); $$ = new Exp (V_BOOL, $1, $2);}
    |Exp AND Exp {if($1.type != V_BOOL || $3.type != V_BOOL) errorMismatch(yylineno); $$ = new Exp(V_BOOL, $1, $2, $3);}
    |Exp OR Exp {if($1.type != V_BOOL || $3.type != V_BOOL) errorMismatch(yylineno); $$ = new Exp(V_BOOL, $1, $2, $3);}
    |Exp RELOP Exp
    |Exp RELOP_EQ Exp  
    |LPAREN Type RPAREN Exp
%%

int main()
{
        Semantic sem = new Semantic();
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
}
